<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Long Ride Home</title>

  <!-- Dyslexivänligt typsnitt (Lexend). Fallback till OpenDyslexic om installerat lokalt. -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Lexend:wght@400;600&display=swap" rel="stylesheet">

  <style>
    html, body{ width:100%; margin:0; padding:0; }
    *, *::before, *::after{ box-sizing:border-box; }

    body{
      font-family: "OpenDyslexic", "Lexend", Arial, sans-serif;
      font-size: 18px;
      line-height: 1.7;
      padding: 20px;
      max-width: none;
      background: #fff;
      color: #111;
    }

    .page{ width:100%; max-width:100%; }

    h1{
      margin: 0 0 10px 0;
      font-size: 22px;
      line-height: 1.3;
    }

    .small{
      font-size: 14px;
      color: #444;
      margin: 0 0 18px 0;
    }

    h2{
      font-size: 20px;
      margin: 0 0 16px 0;
      font-weight: 600;
      line-height: 1.3;
    }

    p{ margin: 0 0 16px 0; }
    p:last-child{ margin-bottom: 0; }

    /* Endast ord/fraser med översättning får understreck */
    .w{
      position: relative;
      cursor: help;
      border-bottom: 1px dotted #666;
      padding: 0 1px;
    }

    .w:hover::after, .w:focus::after{
      content: attr(data-sv);
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 140%;
      background: #111;
      color: #fff;
      padding: 6px 8px;
      border-radius: 8px;
      font-size: 14px;
      white-space: nowrap;
      z-index: 10;
      max-width: 420px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .w:hover::before, .w:focus::before{
      content: "";
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      bottom: 120%;
      border: 6px solid transparent;
      border-top-color: #111;
      z-index: 10;
    }

    /* Ljud: placeholder */
    .audioPlaceholder{
      margin: 0 0 18px 0;
      padding: 12px 14px;
      border: 1px dashed #bbb;
      border-radius: 12px;
      background: #fafafa;
      color: #333;
      font-size: 14px;
    }
    .audioPlaceholder strong{ font-weight: 600; }
    .audioPlaceholder code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      background: #f2f2f2;
      padding: 2px 6px;
      border-radius: 8px;
    }

    /* Ljudspelare (Drive preview) */
    .audio{
      margin: 0 0 18px 0;
    }
    .audio iframe{
      width: 100%;
      height: 90px;
      border: 0;
      border-radius: 12px;
      overflow: hidden;
      display: block;
      background: #f6f6f6;
    }

    /* Felruta om JS kraschar */
    .jsError{
      display:none;
      margin: 0 0 18px 0;
      padding: 12px 14px;
      border: 1px solid #d33;
      border-radius: 12px;
      background: #fff5f5;
      color: #111;
      font-size: 14px;
    }
    .jsError code{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
      background: #fff;
      padding: 2px 6px;
      border-radius: 8px;
      border: 1px solid #eee;
    }
  </style>
</head>

<body>
  <div class="page">
    <h1>The Long Ride Home</h1>
    <div class="small">Listen to the text and then read it. Hover over words you don't understand.</div>

    <!-- Ljud-platshållare -->
    <div class="audioPlaceholder" id="audioPh">
      <strong>Audio placeholder:</strong> Add a Google Drive file ID in <code>DRIVE_FILE_ID</code> to show the player here.
    </div>

    <!-- Spelare (visas när DRIVE_FILE_ID är ifyllt) -->
    <div class="audio" id="audioWrap" style="display:none;">
      <iframe id="audioFrame" allow="autoplay"></iframe>
    </div>

    <div class="jsError" id="jsError">
      <strong>Script error:</strong> Texten kunde inte renderas. Kontrollera att <code>RAW_LIST</code> och <code>TEXT</code> inte är avklippta.
    </div>

    <!-- Texten renderas här -->
    <div id="out" aria-label="Text med hover-översättning"></div>

    <!-- Fallback om JS är avstängt -->
    <noscript>
      <p><strong>Obs:</strong> Den här sidan kräver JavaScript för hover-översättning.</p>
    </noscript>
  </div>

  <script>
    /* =========================
       DU ÄNDRAR ENDAST HÄR
       ========================= */

    // A) Drive-filens ID (från länken .../d/ID/view). Lämna tomt "" om du inte vill ha ljud.
    const DRIVE_FILE_ID = "";

    // B) Ordlista (engelska = svenska)
    // OBS: Om du någon gång får "tom sida", kontrollera att denna backtick ` finns kvar på slutet.
    const RAW_LIST = `a = en/ett
above = ovanför
across = över / tvärs över
after = efter
afternoon = eftermiddag
air = luft
almost = nästan
alone = ensam
along = längs
also = också
always = alltid
and = och
animal = djur
animals = djur (plural)
anna = Anna
any = någon / något
as = som
asks = frågar
at = vid / på
away = bort
back = tillbaka
bad = dålig / illa
because = därför att / eftersom
become = bli
becomes = blir
bed = säng
behind = bakom
belong = tillhöra
best = bäst
better = bättre
between = mellan
birds = fåglar
black = svart
blows = blåser
blue = blå
boat = båt
body = kropp
book = bok
boots = stövlar
both = båda
box = låda
break = bryta / pausa
broken = trasig
brushes = borstar
build = bygga
busy = upptagen
but = men
buy = köpa
by = av / vid
call = ropa / ringa
calls = ringer
calm = lugn
can = kan
cannot = kan inte
car = bil
carefully = försiktigt
careful = försiktig
care = omsorg / bry sig om
checks = kontrollerar
clean = ren
clears = rensar / gör klar
close = nära
closer = närmare
cloud = moln
clouds = moln
coat = rock / (häst)täcke
cold = kall
comes = kommer
could = kunde
country = landsbygd / land
countryside = landsbygd
cover = täcka
covers = täcker
cow = ko
cows = kor
cry = gråta / skrik
dark = mörk
day = dag
days = dagar
decides = bestämmer
decide = bestämma
deep = djup
difficult = svår / svårt
dog = hund
dogs = hundar
down = ner
dry = torr
during = under (t.ex. under dagen)
each = varje
early = tidigt
eat = äta
eats = äter
earth = jord
easy = lätt
even = även / till och med
evening = kväll
every = varje
everyone = alla
everything = allt
exact = exakt
exhausted = utmattad
explain = förklara
explains = förklarar
fast = snabb
father = far / pappa
feels = känner sig / känns
field = fält
fields = fält
find = hitta
finds = hittar
first = första
flowing = flytande / som rinner
forest = skog
freedom = frihet
fresh = frisk / fräsch
from = från
gentle = mild / försiktig
get = få
gets = får
girl = flicka
give = ge
gives = ger
go = gå / åka
goes = går / åker
good = bra
grass = gräs
green = grön
group = grupp
grows = växer
had = hade
hand = hand
hands = händer
has = har
have = ha
head = huvud
hear = höra
heard = hörde
help = hjälp / hjälpa
helps = hjälper
her = hennes / henne
here = här
hill = kulle
hills = kullar
him = honom
his = hans
hold = hålla
home = hem
horse = häst
hours = timmar
house = hus
hurt = skada / göra ont
hurts = gör ont
i = jag
if = om
in = i
inside = inuti / inne
instead = istället
into = in i
is = är
it = det
its = dess
jacket = jacka
keep = behålla / hålla
keeps = håller
know = veta / känna till
knows = vet / känner till
leave = lämna
leg = ben
legs = ben (plural)
light = ljus
like = som / tycka om
listen = lyssna
listens = lyssnar
little = liten
live = leva / bo
lives = bor / lever
long = lång
look = titta
looks = ser
many = många
moment = ögonblick
more = mer
most = mest
move = röra / flytta
moves = rör sig / flyttar
must = måste
near = nära
nearby = i närheten
need = behöva
needs = behöver
never = aldrig
not = inte
of = av
off = av / bort
often = ofta
on = på
one = en / ett
only = bara / endast
or = eller
other = annan
out = ut
over = över
parents = föräldrar
path = stig / väg
people = människor
phone = telefon
proud = stolt
puts = lägger
quiet = tyst
quickly = snabbt
river = flod / å
ride = rida
rides = rider
roads = vägar
safe = säker
says = säger
see = se
sees = ser
seems = verkar
she = hon
small = liten
smells = luktar
soft = mjuk
sound = ljud
storm = Storm (egennamn) / storm
strong = stark
stronger = starkare
suddenly = plötsligt
sun = sol
temperature = temperatur
that = att / det / den
the = den / det / de
their = deras
then = då / sedan
there = där
they = de
think = tänka
thinks = tänker
this = detta / den här
through = genom
tired = trött
to = till / att
toward = mot
trees = träd
turns = svänger / vänder
up = upp
use = använda
uses = använder
wait = vänta
waits = väntar
walks = går
warm = varm
was = var
watch = titta på / klocka
watches = tittar på
water = vatten
weather = väder
well = bra / väl
when = när
where = var / vart
while = medan
wide = bred / vid
wind = vind
with = med
without = utan
would = skulle
wrong = fel
year = år
you = du / ni
your = din / ditt / era`;

    // C) Texten (tomrad = nytt stycke)
    const TEXT = `The Girl and the Long Ride Home

Anna is fifteen years old, and she lives in the countryside with her parents. Their house stands near wide fields, rolling green hills, and a quiet forest that looks dark in the evening. Anna loves animals, but she feels a special connection to her horse. His name is Storm. He is strong, calm, and surprisingly fast, and he always seems to understand her mood.

Every morning Anna wakes up early, even when the air feels cold. She eats breakfast, puts on her boots, and walks to the stable. Storm waits for her and moves his head when he sees her, as if he says hello. Anna brushes his coat carefully and checks his saddle and reins. She talks to him in a soft voice, because it helps him relax. Then she rides Storm out into the open fields. She rides for many hours because it gives her freedom, and it clears her mind.

Anna rides along small roads and narrow paths between farms. She sees birds above her, and cows that watch her from behind fences. The air smells of grass and earth, and it feels clean and fresh. Sometimes she stops near a river so Storm can drink water. She sits quietly for a moment and listens to the flowing water. She feels safe because she knows this area very well, and she knows most of the people who live nearby.

In the afternoon, dark clouds move across the sky and cover the sun. The wind grows stronger, and the temperature drops a little. Anna looks up and decides to go home before the weather becomes dangerous. She turns Storm toward the forest path. This path is shorter, but it is also quiet and narrow, and it feels lonely when the light disappears.

As they ride through the forest, Anna suddenly hears a strange sound. Storm stops at once and does not move. Anna listens carefully. She hears a soft cry, almost like a weak call for help. The sound comes from behind a group of trees. Anna feels nervous, but she stays calm and rides closer, slowly and carefully.

Behind the trees she sees a small dog. The dog sits near a broken fence, and it looks scared and exhausted. One of its legs hurts, and it does not stand up. Anna gets off her horse and walks toward the dog in small steps. She speaks in a calm voice and keeps her hands low. The dog looks at her, but it does not run away.

Anna thinks quickly. She cannot leave the dog alone in the forest, especially with the storm coming. She takes off her jacket and wraps it around the dog to keep it warm. Then she uses her phone and calls her parents. She explains where she is, what she sees, and why she needs help.

Her parents drive to the forest in their car. While she waits, Anna stays close to the dog and watches its breathing. Storm stands quietly beside her, patient and steady. After some time, her parents arrive. They lift the dog carefully into the car and drive to the animal doctor.

In the evening, Anna finally goes home. She feels tired, but also proud and relieved. She knows she does the right thing, even if it is difficult. Storm eats his food in the stable, and Anna gives him a gentle pat. It is a long day, but it is a good day.`;

    /* =========================
       INGEN ÄNDRING UNDER HÄR
       ========================= */

    function normalizeKey(raw){
      return raw.trim().replace(/\s+/g, " ").toLocaleLowerCase("en-US");
    }

    function buildDict(raw){
      const dict = {};
      (raw || "").split("\n").forEach(line => {
        const trimmed = (line || "").trim();
        if(!trimmed) return;

        const idx = trimmed.indexOf("=");
        if(idx === -1) return;

        const left = trimmed.slice(0, idx).trim();
        const right = trimmed.slice(idx + 1).trim();
        if(!left || !right) return;

        dict[normalizeKey(left)] = right;
      });
      return dict;
    }

    function tokenizeEnglish(text){
      const re = /[A-Za-z]+(?:-[A-Za-z]+)*|[0-9]+|\s+|[^A-Za-z0-9\s]+/g;
      return text.match(re) || [];
    }

    function isWord(tok){
      return /^[A-Za-z]+(?:-[A-Za-z]+)*$/.test(tok) || /^[0-9]+$/.test(tok);
    }

    function isWhitespace(tok){
      return /^\s+$/.test(tok);
    }

    function renderInline(container, text, dict){
      const tokens = tokenizeEnglish(text);

      const keys = Object.keys(dict);
      const maxWords = keys.length
        ? keys.map(k => k.split(" ").length).reduce((a,b) => Math.max(a,b), 1)
        : 1;

      let i = 0;
      while(i < tokens.length){
        const tok = tokens[i];

        if(!isWord(tok)){
          container.appendChild(document.createTextNode(tok));
          i += 1;
          continue;
        }

        let matched = false;

        for(let k = maxWords; k >= 2; k--){
          let j = i;
          let words = [];
          let endIndex = i;

          while(words.length < k){
            if(j >= tokens.length) break;
            if(!isWord(tokens[j])) break;

            words.push(tokens[j]);
            endIndex = j;

            if(words.length === k) break;

            j += 1;
            if(j >= tokens.length || !isWhitespace(tokens[j])){
              words = [];
              break;
            }
            while(j < tokens.length && isWhitespace(tokens[j])) j += 1;
          }

          if(words.length === k){
            const key = normalizeKey(words.join(" "));
            const sv = dict[key];
            if(sv){
              const segment = tokens.slice(i, endIndex + 1).join("");
              const span = document.createElement("span");
              span.className = "w";
              span.textContent = segment;
              span.setAttribute("tabindex", "0");
              span.setAttribute("data-sv", sv);
              container.appendChild(span);

              i = endIndex + 1;
              matched = true;
              break;
            }
          }
        }

        if(matched) continue;

        const sv1 = dict[normalizeKey(tok)];
        if(sv1){
          const span1 = document.createElement("span");
          span1.className = "w";
          span1.textContent = tok;
          span1.setAttribute("tabindex", "0");
          span1.setAttribute("data-sv", sv1);
          container.appendChild(span1);
        } else {
          container.appendChild(document.createTextNode(tok));
        }

        i += 1;
      }
    }

    function setupAudio(){
      const ph = document.getElementById("audioPh");
      const wrap = document.getElementById("audioWrap");
      const frame = document.getElementById("audioFrame");
      if(!wrap || !frame) return;

      const id = (DRIVE_FILE_ID || "").trim();
      if(!id){
        wrap.style.display = "none";
        if(ph) ph.style.display = "block";
        return;
      }

      if(ph) ph.style.display = "none";
      frame.src = "https://drive.google.com/file/d/" + encodeURIComponent(id) + "/preview";
      wrap.style.display = "block";
    }

    function render(){
      setupAudio();

      const dict = buildDict(RAW_LIST);
      const out = document.getElementById("out");
      out.innerHTML = "";

      const clean = (TEXT || "").replace(/\r\n/g, "\n").trim();
      const blocks = clean.split(/\n\s*\n+/);

      blocks.forEach((block, idx) => {
        const blockText = block.replace(/\n+/g, " ").replace(/\s+/g, " ").trim();

        if(idx === 0){
          const h2 = document.createElement("h2");
          renderInline(h2, blockText, dict);
          out.appendChild(h2);
        } else {
          const p = document.createElement("p");
          renderInline(p, blockText, dict);
          out.appendChild(p);
        }
      });
    }

    try{
      render();
    } catch(e){
      console.error(e);
      const el = document.getElementById("jsError");
      if(el) el.style.display = "block";
    }
  </script>
</body>
</html>
